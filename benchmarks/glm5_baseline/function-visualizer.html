<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Èñ¢Êï∞„Éì„Ç∏„É•„Ç¢„É©„Ç§„Ç∂„Éº</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .graph-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            position: relative;
        }

        #graphCanvas {
            width: 100%;
            height: 500px;
            background: #0f0f1a;
            border-radius: 10px;
            cursor: crosshair;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #a0a0a0;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .preset-btn {
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .preset-btn:hover {
            background: rgba(0, 212, 255, 0.4);
            transform: translateY(-2px);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00d4ff;
            border-radius: 8px;
            padding: 10px 15px;
            pointer-events: none;
            display: none;
            z-index: 100;
            font-size: 0.9rem;
        }

        .tooltip-row {
            margin: 3px 0;
        }

        .tooltip-label {
            color: #a0a0a0;
        }

        .tooltip-value {
            color: #00d4ff;
            font-weight: bold;
        }

        .error-message {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff4444;
            color: #ff6b6b;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .zoom-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .zoom-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(123, 44, 191, 0.3);
            color: #c77dff;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
        }

        .zoom-btn:hover {
            background: rgba(123, 44, 191, 0.5);
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .range-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .range-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .range-group input {
            width: 100%;
        }

        .color-picker-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .color-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-item input[type="color"] {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìä Èñ¢Êï∞„Éì„Ç∏„É•„Ç¢„É©„Ç§„Ç∂„Éº</h1>
        </header>

        <div class="main-content">
            <div class="graph-container">
                <canvas id="graphCanvas"></canvas>
                <div class="tooltip" id="tooltip">
                    <div class="tooltip-row">
                        <span class="tooltip-label">x: </span>
                        <span class="tooltip-value" id="tooltipX">0</span>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">f(x): </span>
                        <span class="tooltip-value" id="tooltipFx">0</span>
                    </div>
                    <div class="tooltip-row">
                        <span class="tooltip-label">f'(x): </span>
                        <span class="tooltip-value" id="tooltipDfx">0</span>
                    </div>
                </div>
                <div class="legend" id="legend"></div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Èñ¢Êï∞Âºè f(x)</label>
                    <input type="text" id="functionInput" value="sin(x)" placeholder="‰æã: sin(x), x^2, exp(x)">
                    <div class="error-message" id="errorMessage"></div>
                </div>

                <div class="control-group">
                    <label>„Éó„É™„Çª„ÉÉ„ÉàÈñ¢Êï∞</label>
                    <div class="preset-buttons">
                        <button class="preset-btn" data-func="sin(x)">sin(x)</button>
                        <button class="preset-btn" data-func="cos(x)">cos(x)</button>
                        <button class="preset-btn" data-func="tan(x)">tan(x)</button>
                        <button class="preset-btn" data-func="log(x)">log(x)</button>
                        <button class="preset-btn" data-func="exp(x)">exp(x)</button>
                        <button class="preset-btn" data-func="sqrt(x)">sqrt(x)</button>
                        <button class="preset-btn" data-func="abs(x)">abs(x)</button>
                        <button class="preset-btn" data-func="x^2">x^2</button>
                        <button class="preset-btn" data-func="x^3 - 3*x">x¬≥-3x</button>
                        <button class="preset-btn" data-func="sin(x)*cos(x)">sin*cos</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Ë°®Á§∫ÁØÑÂõ≤</label>
                    <div class="range-inputs">
                        <div class="range-group">
                            <label>XÊúÄÂ∞è</label>
                            <input type="text" id="xMin" value="-10">
                        </div>
                        <div class="range-group">
                            <label>XÊúÄÂ§ß</label>
                            <input type="text" id="xMax" value="10">
                        </div>
                        <div class="range-group">
                            <label>YÊúÄÂ∞è</label>
                            <input type="text" id="yMin" value="-10">
                        </div>
                        <div class="range-group">
                            <label>YÊúÄÂ§ß</label>
                            <input type="text" id="yMax" value="10">
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label>Ë°®Á§∫„Ç™„Éó„Ç∑„Éß„É≥</label>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="showDerivative" checked>
                            <label style="margin:0">Â∞éÈñ¢Êï∞ f'(x)</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showTangent">
                            <label style="margin:0">Êé•Á∑ö</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showGrid" checked>
                            <label style="margin:0">„Ç∞„É™„ÉÉ„Éâ</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="autoScale">
                            <label style="margin:0">Ëá™Âãï„Çπ„Ç±„Éº„É´</label>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label>Ëâ≤Ë®≠ÂÆö</label>
                    <div class="color-picker-group">
                        <div class="color-item">
                            <input type="color" id="funcColor" value="#00d4ff">
                            <label style="margin:0;font-size:0.8rem">f(x)</label>
                        </div>
                        <div class="color-item">
                            <input type="color" id="derivColor" value="#ff6b6b">
                            <label style="margin:0;font-size:0.8rem">f'(x)</label>
                        </div>
                        <div class="color-item">
                            <input type="color" id="tangentColor" value="#ffd93d">
                            <label style="margin:0;font-size:0.8rem">Êé•Á∑ö</label>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label>„Ç∫„Éº„É†</label>
                    <div class="zoom-controls">
                        <button class="zoom-btn" id="zoomIn">+ „Ç∫„Éº„É†„Ç§„É≥</button>
                        <button class="zoom-btn" id="zoomOut">- „Ç∫„Éº„É†„Ç¢„Ç¶„Éà</button>
                        <button class="zoom-btn" id="resetZoom">„É™„Çª„ÉÉ„Éà</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class FunctionVisualizer {
            constructor() {
                this.canvas = document.getElementById('graphCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.tooltip = document.getElementById('tooltip');
                this.errorMessage = document.getElementById('errorMessage');
                
                this.xMin = -10;
                this.xMax = 10;
                this.yMin = -10;
                this.yMax = 10;
                
                this.funcColor = '#00d4ff';
                this.derivColor = '#ff6b6b';
                this.tangentColor = '#ffd93d';
                
                this.currentFunction = null;
                this.currentDerivative = null;
                this.mouseX = null;
                
                this.setupCanvas();
                this.bindEvents();
                this.parseAndDraw();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                this.width = rect.width;
                this.height = rect.height;
            }

            bindEvents() {
                document.getElementById('functionInput').addEventListener('input', () => this.parseAndDraw());
                
                ['xMin', 'xMax', 'yMin', 'yMax'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.updateRange());
                });

                document.getElementById('showDerivative').addEventListener('change', () => this.draw());
                document.getElementById('showTangent').addEventListener('change', () => this.draw());
                document.getElementById('showGrid').addEventListener('change', () => this.draw());
                document.getElementById('autoScale').addEventListener('change', () => this.autoScale());

                document.getElementById('funcColor').addEventListener('input', (e) => {
                    this.funcColor = e.target.value;
                    this.draw();
                });
                document.getElementById('derivColor').addEventListener('input', (e) => {
                    this.derivColor = e.target.value;
                    this.draw();
                });
                document.getElementById('tangentColor').addEventListener('input', (e) => {
                    this.tangentColor = e.target.value;
                    this.draw();
                });

                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.getElementById('functionInput').value = btn.dataset.func;
                        this.parseAndDraw();
                    });
                });

                document.getElementById('zoomIn').addEventListener('click', () => this.zoom(0.8));
                document.getElementById('zoomOut').addEventListener('click', () => this.zoom(1.25));
                document.getElementById('resetZoom').addEventListener('click', () => this.resetZoom());

                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => this.hideTooltip());

                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.draw();
                });
            }

            parseFunction(expr) {
                let processed = expr
                    .replace(/\^/g, '**')
                    .replace(/sin/g, 'Math.sin')
                    .replace(/cos/g, 'Math.cos')
                    .replace(/tan/g, 'Math.tan')
                    .replace(/log/g, 'Math.log')
                    .replace(/ln/g, 'Math.log')
                    .replace(/exp/g, 'Math.exp')
                    .replace(/sqrt/g, 'Math.sqrt')
                    .replace(/abs/g, 'Math.abs')
                    .replace(/pi/gi, 'Math.PI')
                    .replace(/e(?![xp])/gi, 'Math.E');
                
                try {
                    const func = new Function('x', `return ${processed}`);
                    func(1);
                    return func;
                } catch (e) {
                    throw new Error('ÁÑ°Âäπ„Å™Êï∞Âºè„Åß„Åô');
                }
            }

            numericalDerivative(f, h = 0.0001) {
                return (x) => {
                    const fx = f(x);
                    if (!isFinite(fx)) return NaN;
                    const fxph = f(x + h);
                    const fxmh = f(x - h);
                    if (!isFinite(fxph) || !isFinite(fxmh)) return NaN;
                    return (fxph - fxmh) / (2 * h);
                };
            }

            parseAndDraw() {
                const input = document.getElementById('functionInput').value;
                this.hideError();

                try {
                    this.currentFunction = this.parseFunction(input);
                    this.currentDerivative = this.numericalDerivative(this.currentFunction);
                    
                    if (document.getElementById('autoScale').checked) {
                        this.autoScale();
                    }
                    
                    this.draw();
                    this.updateLegend();
                } catch (e) {
                    this.showError(e.message);
                }
            }

            updateRange() {
                this.xMin = parseFloat(document.getElementById('xMin').value) || -10;
                this.xMax = parseFloat(document.getElementById('xMax').value) || 10;
                this.yMin = parseFloat(document.getElementById('yMin').value) || -10;
                this.yMax = parseFloat(document.getElementById('yMax').value) || 10;
                this.draw();
            }

            showError(msg) {
                this.errorMessage.textContent = msg;
                this.errorMessage.style.display = 'block';
            }

            hideError() {
                this.errorMessage.style.display = 'none';
            }

            toCanvasX(x) {
                return (x - this.xMin) / (this.xMax - this.xMin) * this.width;
            }

            toCanvasY(y) {
                return this.height - (y - this.yMin) / (this.yMax - this.yMin) * this.height;
            }

            toMathX(canvasX) {
                return this.xMin + canvasX / this.width * (this.xMax - this.xMin);
            }

            toMathY(canvasY) {
                return this.yMax - canvasY / this.height * (this.yMax - this.yMin);
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                if (document.getElementById('showGrid').checked) {
                    this.drawGrid();
                }
                
                this.drawAxes();
                
                if (this.currentFunction) {
                    this.drawFunction(this.currentFunction, this.funcColor, 2);
                    
                    if (document.getElementById('showDerivative').checked) {
                        this.drawFunction(this.currentDerivative, this.derivColor, 1.5, true);
                    }
                    
                    if (document.getElementById('showTangent').checked && this.mouseX !== null) {
                        this.drawTangent();
                    }
                }
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 0.5;

                const xStep = this.calculateGridStep(this.xMax - this.xMin);
                const yStep = this.calculateGridStep(this.yMax - this.yMin);

                for (let x = Math.ceil(this.xMin / xStep) * xStep; x <= this.xMax; x += xStep) {
                    const canvasX = this.toCanvasX(x);
                    this.ctx.beginPath();
                    this.ctx.moveTo(canvasX, 0);
                    this.ctx.lineTo(canvasX, this.height);
                    this.ctx.stroke();
                }

                for (let y = Math.ceil(this.yMin / yStep) * yStep; y <= this.yMax; y += yStep) {
                    const canvasY = this.toCanvasY(y);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, canvasY);
                    this.ctx.lineTo(this.width, canvasY);
                    this.ctx.stroke();
                }
            }

            calculateGridStep(range) {
                const targetSteps = 10;
                const rawStep = range / targetSteps;
                const magnitude = Math.pow(10, Math.floor(Math.log10(rawStep)));
                const normalized = rawStep / magnitude;
                
                let step;
                if (normalized < 1.5) step = 1;
                else if (normalized < 3) step = 2;
                else if (normalized < 7) step = 5;
                else step = 10;
                
                return step * magnitude;
            }

            drawAxes() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 1;

                const originX = this.toCanvasX(0);
                const originY = this.toCanvasY(0);

                if (originX >= 0 && originX <= this.width) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(originX, 0);
                    this.ctx.lineTo(originX, this.height);
                    this.ctx.stroke();
                }

                if (originY >= 0 && originY <= this.height) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, originY);
                    this.ctx.lineTo(this.width, originY);
                    this.ctx.stroke();
                }

                this.drawAxisLabels();
            }

            drawAxisLabels() {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.font = '11px sans-serif';

                const xStep = this.calculateGridStep(this.xMax - this.xMin);
                const yStep = this.calculateGridStep(this.yMax - this.yMin);

                const originY = Math.min(Math.max(this.toCanvasY(0), 15), this.height - 5);
                for (let x = Math.ceil(this.xMin / xStep) * xStep; x <= this.xMax; x += xStep) {
                    if (Math.abs(x) > 0.0001) {
                        const canvasX = this.toCanvasX(x);
                        this.ctx.fillText(this.formatNumber(x), canvasX - 10, originY + 15);
                    }
                }

                const originX = Math.min(Math.max(this.toCanvasX(0), 5), this.width - 25);
                for (let y = Math.ceil(this.yMin / yStep) * yStep; y <= this.yMax; y += yStep) {
                    if (Math.abs(y) > 0.0001) {
                        const canvasY = this.toCanvasY(y);
                        this.ctx.fillText(this.formatNumber(y), originX + 5, canvasY + 4);
                    }
                }
            }

            formatNumber(n) {
                if (Math.abs(n) < 0.0001) return '0';
                if (Math.abs(n) >= 1000 || (Math.abs(n) < 0.01 && Math.abs(n) > 0)) {
                    return n.toExponential(1);
                }
                return parseFloat(n.toPrecision(4)).toString();
            }

            drawFunction(f, color, lineWidth, dashed = false) {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = lineWidth;
                
                if (dashed) {
                    this.ctx.setLineDash([5, 5]);
                } else {
                    this.ctx.setLineDash([]);
                }

                this.ctx.beginPath();
                let started = false;
                let prevY = null;

                for (let i = 0; i <= this.width; i++) {
                    const x = this.toMathX(i);
                    const y = f(x);

                    if (!isFinite(y) || Math.abs(y) > 1e10) {
                        started = false;
                        prevY = null;
                        continue;
                    }

                    const canvasY = this.toCanvasY(y);

                    if (prevY !== null && Math.abs(canvasY - prevY) > this.height * 0.8) {
                        started = false;
                    }

                    if (!started) {
                        this.ctx.moveTo(i, canvasY);
                        started = true;
                    } else {
                        this.ctx.lineTo(i, canvasY);
                    }
                    
                    prevY = canvasY;
                }
                
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            drawTangent() {
                if (this.mouseX === null || !this.currentDerivative) return;

                const x = this.mouseX;
                const y = this.currentFunction(x);
                const slope = this.currentDerivative(x);

                if (!isFinite(y) || !isFinite(slope)) return;

                this.ctx.strokeStyle = this.tangentColor;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([10, 5]);

                const x1 = this.xMin;
                const y1 = y + slope * (x1 - x);
                const x2 = this.xMax;
                const y2 = y + slope * (x2 - x);

                this.ctx.beginPath();
                this.ctx.moveTo(this.toCanvasX(x1), this.toCanvasY(y1));
                this.ctx.lineTo(this.toCanvasX(x2), this.toCanvasY(y2));
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.fillStyle = this.tangentColor;
                this.ctx.beginPath();
                this.ctx.arc(this.toCanvasX(x), this.toCanvasY(y), 6, 0, 2 * Math.PI);
                this.ctx.fill();
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;

                this.mouseX = this.toMathX(canvasX);
                const mouseY = this.toMathY(canvasY);

                if (this.currentFunction) {
                    const fx = this.currentFunction(this.mouseX);
                    const dfx = this.currentDerivative ? this.currentDerivative(this.mouseX) : NaN;

                    document.getElementById('tooltipX').textContent = this.mouseX.toFixed(4);
                    document.getElementById('tooltipFx').textContent = isFinite(fx) ? fx.toFixed(4) : 'Êú™ÂÆöÁæ©';
                    document.getElementById('tooltipDfx').textContent = isFinite(dfx) ? dfx.toFixed(4) : 'Êú™ÂÆöÁæ©';

                    this.tooltip.style.display = 'block';
                    this.tooltip.style.left = (canvasX + 15) + 'px';
                    this.tooltip.style.top = (canvasY + 15) + 'px';

                    if (document.getElementById('showTangent').checked) {
                        this.draw();
                    }
                }
            }

            hideTooltip() {
                this.tooltip.style.display = 'none';
                this.mouseX = null;
                if (document.getElementById('showTangent').checked) {
                    this.draw();
                }
            }

            zoom(factor) {
                const xCenter = (this.xMin + this.xMax) / 2;
                const yCenter = (this.yMin + this.yMax) / 2;
                const xRange = (this.xMax - this.xMin) * factor;
                const yRange = (this.yMax - this.yMin) * factor;

                this.xMin = xCenter - xRange / 2;
                this.xMax = xCenter + xRange / 2;
                this.yMin = yCenter - yRange / 2;
                this.yMax = yCenter + yRange / 2;

                this.updateRangeInputs();
                this.draw();
            }

            resetZoom() {
                this.xMin = -10;
                this.xMax = 10;
                this.yMin = -10;
                this.yMax = 10;
                this.updateRangeInputs();
                this.draw();
            }

            updateRangeInputs() {
                document.getElementById('xMin').value = this.xMin.toFixed(2);
                document.getElementById('xMax').value = this.xMax.toFixed(2);
                document.getElementById('yMin').value = this.yMin.toFixed(2);
                document.getElementById('yMax').value = this.yMax.toFixed(2);
            }

            autoScale() {
                if (!this.currentFunction || !document.getElementById('autoScale').checked) return;

                let minY = Infinity;
                let maxY = -Infinity;
                const steps = 200;
                const xRange = this.xMax - this.xMin;

                for (let i = 0; i <= steps; i++) {
                    const x = this.xMin + (i / steps) * xRange;
                    const y = this.currentFunction(x);
                    if (isFinite(y) && Math.abs(y) < 1e10) {
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }

                if (isFinite(minY) && isFinite(maxY)) {
                    const padding = (maxY - minY) * 0.1 || 1;
                    this.yMin = minY - padding;
                    this.yMax = maxY + padding;
                    this.updateRangeInputs();
                    this.draw();
                }
            }

            updateLegend() {
                const legend = document.getElementById('legend');
                const input = document.getElementById('functionInput').value;
                
                let html = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${this.funcColor}"></div>
                        <span>f(x) = ${input}</span>
                    </div>
                `;
                
                if (document.getElementById('showDerivative').checked) {
                    html += `
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${this.derivColor}"></div>
                            <span>f'(x) - Â∞éÈñ¢Êï∞</span>
                        </div>
                    `;
                }
                
                legend.innerHTML = html;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new FunctionVisualizer();
        });
    </script>
</body>
</html>
