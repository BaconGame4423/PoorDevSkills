# P2残り〜P4 依存関係・インターフェース補完調査

生成日: 2026-02-19
対象: 未移植16ファイル（約2,230行）
前回成果物: [dependency-map.md](./dependency-map.md)

---

## 目次

1. [P2残り: レビューサブシステム](#1-p2残り-レビューサブシステム)
2. [P3: dispatch-step / poll-dispatch](#2-p3-dispatch-step--poll-dispatch)
3. [P4: エントリポイント・ユーティリティ](#3-p4-エントリポイントユーティリティ)
4. [必要な新規型定義](#4-必要な新規型定義)
5. [既存インターフェースの拡張](#5-既存インターフェースの拡張)
6. [必要な新規インターフェース](#6-必要な新規インターフェース)
7. [P1移植済みコードとの接続点一覧](#7-p1移植済みコードとの接続点一覧)
8. [TS移植パターン対照表](#8-ts移植パターン対照表)
9. [移植難易度マトリクス](#9-移植難易度マトリクス)

---

## 1. P2残り: レビューサブシステム

### 1.1 review-setup.sh (182行)

**呼び出し方:**
```
bash review-setup.sh --type <review_type> --target <target_file> --feature-dir <dir> --project-dir <dir>
```

**stdout JSON スキーマ:**
```json
{
  "depth": "light|standard|deep",
  "max_iterations": 2|3|5,
  "next_id": 1,
  "log_path": "/abs/path/review-log-{type}.yaml",
  "id_prefix": "PR|TR|AR|QR|PH",
  "review_type": "planreview|...",
  "personas": [
    { "name": "planreview-pm", "cli": "claude", "model": "sonnet", "agent_name": "planreview-pm" }
  ],
  "fixer": { "cli": "claude", "model": "sonnet", "agent_name": "review-fixer" }
}
```

**内部関数:**

| 関数 | ロジック |
|---|---|
| `get_personas(review_type)` | case 分岐で5種×4ペルソナ名を返す |

**ペルソナマッピング:**

| review_type | ペルソナ (4個) |
|---|---|
| `planreview` | pm / critical / risk / value |
| `tasksreview` | junior / senior / techlead / devops |
| `architecturereview` | architect / performance / security / sre |
| `qualityreview` | code / qa / security / testdesign |
| `phasereview` | qa / ux / regression / docs |

**review_depth 決定ロジック:**
```
深度                   行数変更      ファイル数変更
deep     (max_iter=5)  > 500 行   または > 20 ファイル
standard (max_iter=3)  50〜500 行 または 5〜20 ファイル
light    (max_iter=2)  < 50 行    かつ   < 5 ファイル

※ targetがディレクトリ → find で行数合計
※ targetがファイル    → git diff --stat HEAD
※ config.review_depth != "auto" → 設定値で上書き
```

**副作用:**
| 操作 | 詳細 |
|---|---|
| `bash config-resolver.sh` (N+1回) | 各ペルソナ + fixer の CLI/model 解決 |
| `git diff --stat HEAD` | depth 計算（ファイルターゲット時） |
| `find . -name "*.ts" ...` | 行数カウント（ディレクトリターゲット時） |
| `grep $LOG_PATH` | 既存ログの next_id 計算（読み取りのみ） |

**注意:** review-log.yaml の**新規作成**は行わない。
ログが存在する場合は `grep -oP '[A-Z]+(\d+)'` で最大 ID を読み取るのみ。
実際の初期化と追記は `review-log-update.sh` が担当。

**外部依存:** `utils.sh` (source), `config-resolver.sh`, `jq`, `git`, `find`, `wc`, `grep`

---

### 1.2 review-aggregate.sh (182行)

**呼び出し方:**
```
bash review-aggregate.sh --output-dir <dir> --log <yaml> --id-prefix <PR> --next-id <N> --review-type <type>
```

**stdout JSON スキーマ:**
```json
{
  "total": 5,
  "C": 0, "H": 2, "M": 2, "L": 1,
  "next_id": 6,
  "issues_file": "/abs/path/review-issues-planreview.txt",
  "converged": false,
  "verdicts": "planreview-pm:GO planreview-critical:NO-GO ..."
}
```

**収束条件:** `C == 0 && H == 0` → `converged: true`

**issues_file フォーマット (パイプ区切り):**
```
PR001|H|description|location|persona_name
PR002|M|description|location|persona_name
```

**処理フロー:**
1. `review-log.yaml` から固定済み issues ID を `declare -A FIXED_ISSUES` に収集
2. `$OUTPUT_DIR/*.txt` / `*.json` を走査
3. `ISSUE: C|H|M|L | description | location` 行を抽出
4. Cross-persona dedup: 同一 `location` の重複をスキップ
5. ID 割り当て: `{PREFIX}{NNN}` (ゼロ埋め3桁)
6. 結果を `review-issues-{type}.txt` + `review-issues-latest.txt` に cp

**副作用:**
| 操作 | ファイル | 条件 |
|---|---|---|
| `mktemp /tmp/poor-dev-issues-$$.XXXXXX` | 一時ファイル | 常時 |
| `rm -f ISSUES_FILE` | 一時ファイル | EXIT trap |
| `cp $ISSUES_FILE $STABLE_ISSUES` | `$FD/review-issues-{type}.txt` | LOG_PATH + REVIEW_TYPE 指定時 |
| `cp $ISSUES_FILE review-issues-latest.txt` | `$FD/review-issues-latest.txt` | LOG_PATH 指定時 |

**外部依存:** `utils.sh` (source), `jq`, `mktemp`, `cp`, `cut`, `grep`, `sed`

---

### 1.3 review-log-update.sh (90行)

**呼び出し方:**
```
bash review-log-update.sh --log <path> --issues-file <path> --verdicts "<str>" --iteration <N> --fixed <id1,id2,...>
```

**stdout:** 更新後の `$LOG_PATH` (絶対パス文字列)

**初期化ヘッダー (ログ未存在時に新規作成):**
```yaml
# Review Log
# Auto-generated by review-runner.sh
created: 2026-02-19T12:00:00Z
iterations:
```

**追記フォーマット:**
```yaml
  - iteration: 1
    timestamp: 2026-02-19T12:00:00Z
    verdicts: "planreview-pm:GO planreview-critical:NO-GO"
    issues:
      - id: PR001
        severity: H
        description: "..."
        location: "..."
        persona: planreview-critical
    fixed:
      - PR001
```

**副作用:**
| 操作 | 詳細 |
|---|---|
| `mkdir -p $(dirname $LOG_PATH)` | ディレクトリ自動作成 |
| `cat > $LOG_PATH <<EOF` | ログ新規作成 |
| `sed -i 's/^iterations: \[\]$/iterations:/' $LOG_PATH` | レガシーログ修正 |
| `echo ... >> $LOG_PATH` | イテレーションブロック追記 |

**外部依存:** `utils.sh` (source), `date`, `sed`, `mkdir`

---

## 2. P3: dispatch-step / poll-dispatch

### 2.1 dispatch-step.sh (90行)

**呼び出し方:**
```
bash dispatch-step.sh <step> <project_dir> <prompt_file> [idle_timeout=120] [max_timeout=600] [result_file]
```

**stdout:** `poll-dispatch.sh` の JSON summary をそのままパススルー（または heartbeat JSONL）

**exit code:** `poll-dispatch.sh` の exit code をそのままパススルー

**生成コマンドファイルの内容:**

CLI = opencode の場合:
```bash
#!/usr/bin/env bash
cd "$PROJECT_DIR" && opencode run --model "$MODEL" --format json "$(cat "$PROMPT_FILE")"
```

CLI = claude の場合:
```bash
#!/usr/bin/env bash
cd "$PROJECT_DIR" && cat "$PROMPT_FILE" | env -u CLAUDECODE claude -p --model "$MODEL" \
  --no-session-persistence --output-format text --dangerously-skip-permissions
```

**一時ファイル:**
| ファイル | 後処理 |
|---|---|
| `/tmp/poor-dev-cmd-{step}-$$.sh` | 実行後 rm -f（常時） |
| `/tmp/poor-dev-output-{step}-$$.txt` | 呼び出し元が使用（削除しない） |
| `/tmp/poor-dev-progress-{step}-$$.txt` | 呼び出し元が使用（削除しない） |

**副作用:**
1. `bash config-resolver.sh <step> [config_path]` → CLI/model 解決
2. `/tmp/poor-dev-cmd-{step}-$$.sh` 作成・chmod +x
3. `bash poll-dispatch.sh <cmd_file> <output_file> <progress_file> ...` 実行
4. `rm -f cmd_file` (exit 後)

**外部依存:** (source なし), `config-resolver.sh`, `poll-dispatch.sh`, `jq`

---

### 2.2 poll-dispatch.sh (188行)

**呼び出し方:**
```
bash poll-dispatch.sh <command_file> <output_file> <progress_file> <idle_timeout> <max_timeout> [step_name] [result_file]
```

**stdout:**
- `result_file` 未指定 → JSON summary (backward-compatible)
- `result_file` 指定 → heartbeat JSONL (15秒ごと) + JSON summary を result_file に書き込み

**heartbeat JSONL フォーマット:**
```json
{"heartbeat":true,"step":"implement","elapsed":30,"output_bytes":1024}
```

**JSON summary スキーマ:**
```json
{
  "exit_code": 0,
  "elapsed": 120,
  "timeout_type": "none|idle|max",
  "verdict": "GO|CONDITIONAL|NO-GO|null",
  "errors": ["[ERROR: ...]"],
  "clarifications": ["[NEEDS CLARIFICATION: ...]"]
}
```

**ポーリングループ詳細:**

```
コマンドファイルバリデーション:
  grep -m1 -oE '\b(opencode|claude|cat)\b' → 既知 CLI のみ許可

プロセス起動:
  env -u CLAUDECODE bash <command_file> > output_file 2>&1 &
  PID=$!

ポーリング (inotifywait あれば event-driven、なければ sleep 1):
  - 出力サイズ差分チェック
  - [PROGRESS:...] / [REVIEW-PROGRESS:...] マーカー → progress_file に追記
  - step_finish { reason:"stop" } 検出 → 10秒グレース後 kill + wait → 正常終了
  - idle timeout (OUTPUT_STARTED=true 後): IDLE >= IDLE_TIMEOUT → kill, exit 124
  - max timeout: ELAPSED >= MAX_TIMEOUT → kill, exit 124

出力解析:
  VERDICT: grep -oP '^v: \K(GO|CONDITIONAL|NO-GO)' (tail -80 行)
  ERRORS: grep -oP '\[ERROR: [^\]]*\]'
    ※ フォルスポジ除外: <...> テンプレート / [ERROR: description]
  CLARIFICATIONS: grep -oP '\[NEEDS CLARIFICATION: [^\]]*\]'
    ※ フォルスポジ除外: <...> テンプレート / [NEEDS CLARIFICATION: question]
```

**exit code:**
| 値 | 意味 |
|---|---|
| 0 | 正常終了 (コマンドの exit code) |
| 124 | タイムアウト (idle または max) |
| 1 | 入力バリデーションエラー |

**外部依存:** (source なし), `inotifywait` (optional), `jq`, `grep`, `kill`, `wait`, `date`, `wc`

---

## 3. P4: エントリポイント・ユーティリティ

### 3.1 compose-prompt.sh (139行)

**呼び出し方:**
```
bash compose-prompt.sh <command_file> <output_file> [--header non_interactive|readonly] [--context key=file ...]
```

**stdout:** なし（output_file への書き込みのみ）

**ヘッダー種別:**
- `non_interactive`: NON_INTERACTIVE_HEADER (パイプラインサブエージェント指示)
- `readonly`: READONLY_HEADER (read-only mode / specify用)

**ヘッダー内容は compose-prompt.sh L23-46 に hardcode。TS移植時も同じ文字列を定数化。**

**YAML frontmatter strip ロジック (awk):**
```
--- で始まる最初の2行を除去。その間の内容は出力しない。
最初の --- を発見 → in_front=1
2番目の --- を発見 → in_front=0, front_done=1
```

**context ファイル処理:**
- `key=file` 形式で指定
- ファイルが存在しない場合は stderr 警告 + スキップ
- 10KB 超 → `head -200` で切り捨て + `[TRUNCATED: ...]` 追記

**副作用:** `$OUTPUT_FILE` への書き込みのみ。副作用ゼロの純粋関数として実装可能。

**外部依存:** (source なし), `awk`, `wc`, `head`, `cat`

---

### 3.2 intake.sh (122行)

**呼び出し方:**
```
bash intake.sh --flow <flow> --project-dir <dir> [--input-file <file>] [--setup-only]
```

**stdin:** ユーザー入力テキスト (--input-file なしの場合)

**stdout JSONL (順序保証):**
```json
{"event":"intake_started","flow":"feature"}
{"event":"branch_created","branch":"005-my-feature","feature_dir":"specs/005-my-feature"}
{"event":"pipeline","status":"starting"}
{"event":"pipeline","status":"background","pid":12345,"feature_dir":"specs/005-my-feature","log":"/abs/path/pipeline.log"}
{"event":"intake_complete","feature_dir":"specs/005-my-feature","branch":"005-my-feature"}
```

**setup-only モード (--setup-only):**
```json
{"event":"setup_complete","feature_dir":"specs/005-my-feature","branch":"005-my-feature","flow":"feature"}
```

**short-name 生成ロジック:**
```bash
echo "$INPUT" | sed 's/[^a-zA-Z0-9 ]//g' |
  awk '{for(i=1;i<=NF&&i<=4;i++) printf "%s%s",$i,(i<4&&i<NF?"-":"")}' |
  tr '[:upper:]' '[:lower:]' | cut -c1-30

# 非ASCII入力フォールバック: "${FLOW}-$(date +%H%M%S)"
```

**副作用:**
| 操作 | ファイル/コマンド |
|---|---|
| 一時ファイル作成 | `/tmp/poor-dev-intake-input-$$.txt` |
| `bash branch-setup.sh <short-name>` | ブランチ + `specs/NNN-name/` 作成 |
| `cp $TEMP_INPUT $FD/input.txt` | ユーザー入力を保存 |
| `nohup bash pipeline-runner.sh ... > pipeline.log &` | バックグラウンド起動 |
| `echo $PIPELINE_PID > $FD/pipeline.pid` | PID ファイル作成 |

**外部依存:** (source なし), `branch-setup.sh`, `pipeline-runner.sh`, `nohup`, `sed`, `awk`

---

### 3.3 intake-and-specify.sh (225行)

**呼び出し方:**
```
bash intake-and-specify.sh --flow <flow> --project-dir <dir> <<< "user input"
```

**stdin:** ユーザー入力テキスト

**stdout:** JSON (単一オブジェクト)
```json
{
  "branch": "005-my-feature",
  "feature_dir": "specs/005-my-feature",
  "spec_content": "# Feature Spec\n...",
  "resumed": false
}
```

**exit code:** 0=success, 1=error, 3=rate-limit

**冪等性:** 現在ブランチが `NNN-` 形式 + `specs/NNN-*` が存在する場合、branch-setup をスキップ

**rate-limit 検出 (exit 3):**
```bash
LOG_DIR="${HOME}/.local/share/opencode/log"
LATEST_LOG=$(ls -t $LOG_DIR/*.log | head -1)
grep -c "Rate limit\|rate_limit\|rate limit" "$LATEST_LOG" > 0
→ pipeline-state.sh set-status rate-limited → exit 3
```

**config 読み取りフィールド:**
- `.polling.idle_timeout` (default: 300)
- `.polling.max_timeout` (default: 600)
- `.command_variant` → "simple" の場合は `poor-dev.specify-simple.md` を使用

**command_file 解決 (優先順位):**
```
1. $PROJECT_DIR/commands/poor-dev.specify.md
2. $PROJECT_DIR/.opencode/command/poor-dev.specify.md
3. 上記の "-simple" バリアント（command_variant=simple の場合）
```

**pipeline-ctx テンプレート:**
```
- FEATURE_DIR: specs/005-my-feature
- BRANCH: 005-my-feature
- Feature: <input.txt の最初の行>
- Step: specify (1/10)
```

**呼び出し子プロセス (順序):**
1. `bash intake.sh --setup-only --input-file ...`
2. `bash pipeline-state.sh init ...`
3. `bash compose-prompt.sh ...`
4. `bash dispatch-step.sh specify ...`
5. `bash extract-output.sh ...`
6. `bash pipeline-state.sh complete-step specify`

**外部依存:** `utils.sh` (source), `intake.sh`, `pipeline-state.sh`, `compose-prompt.sh`, `dispatch-step.sh`, `extract-output.sh`, `jq`, `git`, `ls`

---

### 3.4 config-resolver.sh (65行)

**呼び出し方:**
```
bash config-resolver.sh <step> [config_path=.poor-dev/config.json]
```

**stdout:** `{"cli":"opencode","model":"zai-coding-plan/glm-4.7"}`

**5段階解決チェーン (単一 jq 呼び出し):**
```
1. overrides[step]         → cli + model
2. overrides[category]     → cli + model (category = step のハイフン前部分)
3. step_tiers[step] → tier → tiers[tier]
4. default
5. hardcoded: {"cli":"claude","model":"sonnet"}
```

**category 導出:**
```bash
CATEGORY="${STEP%-*}"  # "planreview-pm" → "planreview"
                       # "implement" → "implement" (ハイフンなし時は STEP と同一)
```

**副作用:** なし（読み取り専用の純粋関数）

**TS 実装方針:** `resolveConfig(step: string, config: PoorDevConfigFull): ConfigResolverResult` として関数化可能。

---

### 3.5 config.sh (462行)

**呼び出し方:** `bash config.sh <subcommand> [args...]`

**config.json フルスキーマ (DEFAULT_CONFIG に基づく):**
```json
{
  "default": { "cli": "opencode", "model": "zai-coding-plan/glm-4.7" },
  "overrides": {
    "fixer": { "cli": "claude", "model": "sonnet" },
    "phasereview": { "cli": "claude", "model": "haiku" }
  },
  "tiers": {
    "T1": { "cli": "claude", "model": "sonnet" },
    "T2": { "cli": "opencode", "model": "minimax-m2.5" },
    "T3": { "cli": "opencode", "model": "minimax-m2.5-lightning" }
  },
  "step_tiers": {
    "specify": "T2", "suggest": "T3", "plan": "T1",
    "planreview": "T2", "tasks": "T2", "tasksreview": "T2",
    "implement": "T2", "architecturereview": "T2",
    "qualityreview": "T2", "phasereview": "T2"
  },
  "review_depth": "auto",
  "speculation": { "enabled": true, "pairs": { "specify": "suggest" } },
  "parallel": { "enabled": true, "strategy": "auto", "max_concurrent": 3 }
}
```

**バリデーション済み値:**
| フィールド | 有効値 |
|---|---|
| cli | `claude` / `opencode` |
| Claude model | `haiku` / `sonnet` / `opus` |
| opencode model | 任意（dynamic） |
| depth | `auto` / `deep` / `standard` / `light` |
| parallel strategy | `auto` / `same-branch` / `worktree` / `phase-split` |

**subcommand 一覧は dependency-map.md §4 config.sh セクションを参照。**

**注意:** `PoorDevConfig` (types.ts) は polling/retry/command_variant 向けに設計されており、
config.sh のフルスキーマ（default/overrides/tiers/step_tiers/speculation/parallel オブジェクト）とは**別型**が必要。

---

### 3.6 branch-setup.sh (85行)

**呼び出し方:** `bash branch-setup.sh <short-name>` (カレントディレクトリ = project_dir であること)

**stdout:** JSON `{ "number": "005", "branch": "005-my-feature", "feature_dir": "specs/005-my-feature" }`

**連番計算アルゴリズム:**
```
MAX_N = max(
  remote branches: NNN- prefix から数値抽出,
  local branches:  NNN- prefix から数値抽出,
  specs/ dirs:     NNN- prefix から数値抽出
)
NEW_N = MAX_N + 1
NUMBER = printf "%03d" $NEW_N
```

**副作用:**
| 操作 | 条件 |
|---|---|
| `git fetch --all --prune` | 常時（エラー無視） |
| `git branch -r` / `git branch` | 連番計算 |
| `git show-ref --verify --quiet refs/heads/$BRANCH` | 衝突チェック |
| `git checkout -b $BRANCH` | ブランチ作成 |
| `mkdir -p $FEATURE_DIR` | ディレクトリ作成 |

---

### 3.7 utils.sh (63行)

**全関数の TS 対応:**

| Bash 関数 | TS 実装先 | 実装方針 |
|---|---|---|
| `json_get(json, jq_expr)` | 廃止 | TypeScript の JSON アクセスで直接対応 |
| `json_get_or(json, jq_expr, default)` | 廃止 | `?? default` で直接対応 |
| `die(message, exit_code?)` | Error throw | `throw new Error(message)` + exit code を Error に付加 |
| `make_temp(prefix)` | node-adapters.ts | `fs.mkdtempSync(path.join(os.tmpdir(), "poor-dev-${prefix}-"))` |
| `cleanup_temp_files()` | node-adapters.ts | `process.on('exit', cleanup)` / `fs.unlinkSync` |
| `read_config(project_dir)` | node-adapters.ts | `JSON.parse(fs.readFileSync(...) \|\| '{}')` |

---

### 3.8 extract-output.sh (58行)

**呼び出し方:** `bash extract-output.sh <output_file> <save_to>`

**stdout:** JSON `{ "status": "ok|error", "bytes": N, "format": "opencode|plaintext" }`

**処理フロー:**
```
Strategy 1 (opencode JSON):
  jq -r 'select(.type=="text") | .part.text // empty' output_file
  → 非空なら FORMAT=opencode
Strategy 2 (plaintext):
  sed '/^\[BRANCH:/d' output_file → save_to
  FORMAT=plaintext

共通後処理: [BRANCH: ...] 行を削除
バリデーション: save_to が空なら die
```

**副作用:** `$SAVE_TO` への書き込み + `mkdir -p $(dirname $SAVE_TO)` のみ

---

### 3.9 resume-pipeline.sh (88行)

**呼び出し方:**
```
bash resume-pipeline.sh --feature-dir <dir> --project-dir <dir>
```

**stdout:** JSON `{ "status": "resumed", "pid": N, "log_path": "...", "flow": "...", "feature_dir": "..." }`

**処理フロー:**
1. `pipeline-state.json` から `flow`, `status` を読み取り
2. `git rev-parse --abbrev-ref HEAD` で現在ブランチ確認
3. status が `awaiting-approval` → `bash pipeline-state.sh clear-approval` を呼び出し
4. `head -1 input.txt` で summary 取得
5. `nohup bash pipeline-runner.sh ... > pipeline.log &`

**副作用:** `pipeline-state.sh clear-approval`, nohup background launch, pipeline.log 上書き, pipeline.pid 上書き

---

### 3.10 apply-clarifications.sh (77行)

**呼び出し方:**
```
bash apply-clarifications.sh <feature_dir> <<< "user answers"
```

**stdout:** JSON `{ "status": "applied", "questions": N, "spec": "/abs/path/spec.md" }`

**追記フォーマット (spec.md への追記):**
```markdown

## Clarifications

### 2026-02-19

**Questions:**

  1. question1
  2. question2

**Answers:**

user_answer_text

```

**副作用:**
| 操作 | 対象 |
|---|---|
| `>> $SPEC_FILE` | spec.md に Clarifications セクション追記 |
| `rm -f $PENDING_FILE` | pending-clarifications.json 削除 |
| `bash pipeline-state.sh clear-approval` | 承認状態クリア |

---

### 3.11 tasks-validate.sh (186行)

**呼び出し方:** `bash tasks-validate.sh <tasks.md path>`

**stdout:** JSON `{ "valid": true, "errors": [...], "warnings": [...], "stats": { "tasks": N, "bad_format": N, "phases": N } }`

**exit code:** 0=valid (warnings OK), 1=invalid, ~~2=warnings only~~ (実際は warnings でも 0)

**バリデーション項目:**

| チェック | エラー/警告 |
|---|---|
| `- [ ] [TXXX]` / `- [X] [TXXX]` パターン | 不正 → ERROR |
| タスク ID なし行 (`- [ ] text` のみ) | ERROR |
| `depends: [TXXX, ...]` → 未定義 ID 参照 | ERROR |
| `[P]` マーカーあり + `files:` なし | WARNING |
| 並列グループ内のファイル glob 重複 | WARNING |

**2パス処理:**
- Pass 1: 全 task ID を収集 + files/parallel メタデータ収集
- Pass 2: depends 参照の存在検証

**並列グループ:**
`[P]` または `[P:group-name]` で指定。グループ内の `files:` フィールドを比較して glob 重複を検出。

---

## 4. 必要な新規型定義

`types.ts` に追加が必要な型：

```typescript
// --- config-resolver.sh の出力 ---
export interface ConfigResolverResult {
  cli: "claude" | "opencode";
  model: string;
}

// --- config.sh のフルスキーマ (PoorDevConfig とは別) ---
export interface CliModelPair {
  cli: "claude" | "opencode";
  model: string;
}

export interface PoorDevConfigFull {
  default: CliModelPair;
  overrides: Record<string, CliModelPair>;
  tiers: Record<string, CliModelPair>;
  step_tiers: Record<string, string>;
  review_depth: "auto" | "deep" | "standard" | "light";
  speculation: {
    enabled: boolean;
    pairs: Record<string, string>;
  };
  parallel: {
    enabled: boolean;
    strategy: "auto" | "same-branch" | "worktree" | "phase-split";
    max_concurrent: number;
  };
  // pipeline-runner.sh が参照するフィールド (polling等) も統合可能
  polling?: {
    idle_timeout: number;
    max_timeout: number;
    step_timeouts?: Record<string, { idle_timeout: number; max_timeout: number }>;
  };
  retry?: Partial<RetryConfig>;
  command_variant?: string;
  review_mode?: "llm" | "bash";
  gates?: Record<string, boolean>;
}

// --- branch-setup.sh の出力 ---
export interface BranchSetupResult {
  number: string;      // "005"
  branch: string;      // "005-my-feature"
  feature_dir: string; // "specs/005-my-feature"
}

// --- extract-output.sh の出力 ---
export interface ExtractOutputResult {
  status: "ok" | "error";
  bytes: number;
  format: "opencode" | "plaintext";
}

// --- tasks-validate.sh の出力 ---
export interface TaskValidateResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
  stats: {
    tasks: number;
    bad_format: number;
    phases: number;
  };
}

// --- review-setup.sh の出力 ---
export interface PersonaConfig {
  name: string;
  cli: string;
  model: string;
  agent_name: string;
}

export interface ReviewSetupResult {
  depth: "light" | "standard" | "deep";
  max_iterations: number;
  next_id: number;
  log_path: string;
  id_prefix: string;
  review_type: string;
  personas: PersonaConfig[];
  fixer: { cli: string; model: string; agent_name: string };
}

// --- review-aggregate.sh の出力 ---
export interface ReviewAggregateResult {
  total: number;
  C: number;
  H: number;
  M: number;
  L: number;
  next_id: number;
  issues_file: string;
  converged: boolean;
  verdicts: string;
}

// --- apply-clarifications.sh の出力 ---
export interface ApplyClarificationsResult {
  status: "applied";
  questions: number;
  spec: string;
}

// --- poll-dispatch.sh の出力 ---
export interface DispatchSummary {
  exit_code: number;
  elapsed: number;
  timeout_type: "none" | "idle" | "max";
  verdict: "GO" | "CONDITIONAL" | "NO-GO" | null;
  errors: string[];
  clarifications: string[];
}
```

---

## 5. 既存インターフェースの拡張

### 5.1 FileSystem インターフェース (`interfaces.ts`) への追加

```typescript
export interface FileSystem {
  // 既存メソッド...

  /** ファイルに追記する（存在しない場合は新規作成） */
  appendFile(path: string, content: string): void;

  /** 一時ファイルを作成し、パスを返す */
  makeTempFile(prefix?: string): string;

  /** ディレクトリを再帰的に作成 */
  mkdirp(path: string): void;

  /** ファイルサイズ (bytes) を返す */
  fileSize(path: string): number;

  /** ファイルの末尾 N バイトを読み取る */
  tailBytes(path: string, bytes: number): string;
}
```

### 5.2 GitOps インターフェース (`interfaces.ts`) への追加

```typescript
export interface GitOps {
  // 既存メソッド...

  /** git diff --stat HEAD の出力 (depth 計算用) */
  diffStat(dir: string): string;

  /** git rev-parse --abbrev-ref HEAD → 現在ブランチ名 */
  currentBranch(dir: string): string;

  /** git branch -r および git branch の出力 */
  listBranches(dir: string, remote?: boolean): string;

  /** git show-ref --verify --quiet refs/heads/<branch> → 存在するか */
  branchExists(dir: string, branch: string): boolean;

  /** git fetch --all --prune */
  fetch(dir: string): void;

  /** git checkout -b <branch> */
  createBranch(dir: string, branch: string): void;

  /** git rev-parse HEAD → コミットハッシュ */
  headCommit(dir: string): string;
}
```

---

## 6. 必要な新規インターフェース

### 6.1 ConfigResolver

```typescript
// interfaces.ts に追加
export interface ConfigResolver {
  /**
   * ステップ名から CLI/model を解決する（5段階チェーン）。
   * config-resolver.sh に対応する純粋関数的インターフェース。
   */
  resolve(step: string, config: PoorDevConfigFull): ConfigResolverResult;
}
```

### 6.2 PromptComposer

```typescript
export interface PromptComposer {
  /**
   * コマンドファイル + ヘッダー + コンテキストからプロンプトファイルを生成する。
   * compose-prompt.sh に対応。
   */
  compose(params: {
    commandFile: string;
    outputFile: string;
    headers?: Array<"non_interactive" | "readonly">;
    contexts?: Array<{ key: string; file: string }>;
  }): void;
}
```

### 6.3 OutputExtractor

```typescript
export interface OutputExtractor {
  /**
   * LLM 出力ファイルからアーティファクトを抽出する。
   * extract-output.sh に対応。
   */
  extract(outputFile: string, saveTo: string): ExtractOutputResult;
}
```

### 6.4 BranchSetup

```typescript
export interface BranchSetup {
  /**
   * 連番ブランチと specs/ ディレクトリを作成する。
   * branch-setup.sh に対応。
   * @param projectDir 作業ディレクトリ（git root）
   * @param shortName ブランチ名の短縮名
   */
  setup(projectDir: string, shortName: string): BranchSetupResult;
}
```

### 6.5 PollDispatch

```typescript
export interface PollDispatch {
  /**
   * コマンドを非同期実行し、ポーリングでモニタリングする。
   * poll-dispatch.sh に対応。
   * @returns DispatchSummary
   */
  run(params: {
    commandFile: string;
    outputFile: string;
    progressFile: string;
    idleTimeout: number;
    maxTimeout: number;
    stepName?: string;
    resultFile?: string;
  }): Promise<DispatchSummary>;
}
```

### 6.6 TasksValidator

```typescript
export interface TasksValidator {
  /**
   * tasks.md を検証する。
   * tasks-validate.sh に対応。
   */
  validate(tasksFile: string): TaskValidateResult;
}
```

---

## 7. P1移植済みコードとの接続点一覧

| 未移植ファイル | 使用する移植済みインターフェース | 使用するメソッド |
|---|---|---|
| review-setup.sh | `GitOps` | `diffStat()`, `hasGitDir()` |
| review-setup.sh | `FileSystem` | `exists()`, `readFile()` |
| review-aggregate.sh | `FileSystem` | `readFile()`, `writeFile()`, `makeTempFile()`, `fileSize()` |
| review-log-update.sh | `FileSystem` | `exists()`, `appendFile()`, `mkdirp()`, `readFile()` |
| dispatch-step.sh | `PipelineStateManager` | — (直接使用なし) |
| poll-dispatch.sh | `FileSystem` | `makeTempFile()`, `fileSize()`, `tailBytes()`, `writeFile()` |
| compose-prompt.sh | `FileSystem` | `readFile()`, `writeFile()`, `fileSize()` |
| intake.sh | `GitOps` | (branch-setup 経由) |
| intake.sh | `PipelineStateManager` | — (pipeline-runner 経由) |
| intake-and-specify.sh | `PipelineStateManager` | `init()`, `completeStep()`, `setStatus()` |
| config-resolver.sh | — | (純粋関数、DI不要) |
| config.sh | `FileSystem` | `readFile()`, `writeFile()`, `mkdirp()` |
| branch-setup.sh | `GitOps` | `fetch()`, `listBranches()`, `branchExists()`, `createBranch()` |
| extract-output.sh | `FileSystem` | `exists()`, `readFile()`, `writeFile()`, `mkdirp()`, `fileSize()` |
| resume-pipeline.sh | `PipelineStateManager` | `read()`, `clearApproval()` |
| resume-pipeline.sh | `GitOps` | `currentBranch()` |
| apply-clarifications.sh | `FileSystem` | `readFile()`, `appendFile()`, `removeFile()` |
| apply-clarifications.sh | `PipelineStateManager` | `clearApproval()` |
| tasks-validate.sh | `FileSystem` | `readFile()` |

---

## 8. TS移植パターン対照表

| Bash パターン | TypeScript 置換 |
|---|---|
| `bash subscript.sh args` | 直接関数呼び出し（DI注入済み） |
| `source utils.sh` | `import { ... } from './utils.js'` |
| `nohup bash script.sh ... &` | `child_process.spawn(cmd, args, { detached: true, stdio: 'ignore' }); proc.unref()` |
| `inotifywait -e modify file` | `fs.watch(file, callback)` + fallback: `setInterval(poll, 1000)` |
| `kill $PID` | `proc.kill()` |
| `wait $PID` | `proc.on('exit', ...)` / `await new Promise(...)` |
| `mktemp /tmp/poor-dev-X-$$.XXXXXX` | `fs.mkdtempSync(path.join(os.tmpdir(), 'poor-dev-X-'))` |
| `trap cleanup EXIT INT TERM` | `process.on('exit', cleanup)` + `process.on('SIGINT', cleanup)` |
| `declare -A map; map[key]=val` | `Map<string, string>` または `Record<string, string>` |
| `jq -r '.field'` | `config.field` (型安全なアクセス) |
| `grep -oP '\[ERROR: [^\]]*\]'` | `RegExp` + `String.prototype.match()` |
| `echo "$str" \| jq -R -s 'split("\n") ...'` | `str.split('\n').filter(...)` |
| `>> file` (追記) | `fs.appendFileSync()` |
| `sed -i 's/pattern/replace/' file` | `str.replace()` + `fs.writeFileSync()` |
| `cat > file <<EOF` | `fs.writeFileSync(path, content)` |
| `wc -c < file` | `fs.statSync(file).size` |
| `tail -c +N file` | `Buffer.from(fs.readFileSync(file)).slice(N-1).toString()` |
| `tail -80 file` | `content.split('\n').slice(-80).join('\n')` |
| `head -1 file` | `content.split('\n')[0]` |
| `date -u +"%Y-%m-%dT%H:%M:%SZ"` | `new Date().toISOString()` |

---

## 9. 移植難易度マトリクス

### P2残り

| ファイル | 難易度 | 理由 |
|---|---|---|
| `review-setup.sh` | ★★☆ (中) | git diff 依存・深度計算。インターフェース接続点が多い |
| `review-aggregate.sh` | ★★☆ (中) | YAML パース・dedup ロジック・一時ファイル管理 |
| `review-log-update.sh` | ★☆☆ (低) | YAML 追記のみ。sed -i を文字列置換に変換するだけ |

### P3

| ファイル | 難易度 | 理由 |
|---|---|---|
| `dispatch-step.sh` | ★★☆ (中) | CLI コマンドライン生成・ファイル管理。poll-dispatch との境界が重要 |
| `poll-dispatch.sh` | ★★★ (高) | プロセス管理・ポーリング・タイムアウト。Node.js の非同期 IO に根本的に再設計が必要 |

### P4

| ファイル | 難易度 | 理由 |
|---|---|---|
| `compose-prompt.sh` | ★☆☆ (低) | 文字列結合。awk frontmatter strip をパーサーに置換 |
| `intake.sh` | ★★☆ (中) | nohup background launch。JSONL 出力パターン |
| `intake-and-specify.sh` | ★★☆ (中) | 複合操作。冪等性ロジックと rate-limit 検出が複雑 |
| `config-resolver.sh` | ★☆☆ (低) | 純粋関数。jq を TS 型付きアクセスに置換するだけ |
| `config.sh` | ★★☆ (中) | 大量のサブコマンド。バリデーションロジックを型で置換 |
| `branch-setup.sh` | ★★☆ (中) | git 操作多数。`simple-git` ライブラリの活用を検討 |
| `utils.sh` | ★☆☆ (低) | 全て TS で慣用的に書き直せる |
| `extract-output.sh` | ★☆☆ (低) | JSON パース + 文字列フィルタリングのみ |
| `resume-pipeline.sh` | ★★☆ (中) | nohup background launch。intake.sh と同じパターン |
| `apply-clarifications.sh` | ★☆☆ (低) | ファイル追記 + JSON パース |
| `tasks-validate.sh` | ★★☆ (中) | 2パス正規表現パース。バグが出やすい |

---

## 補足: poll-dispatch.sh の TS 実装方針

`poll-dispatch.sh` は P3/P4 全体で最も複雑。以下の設計を推奨：

```typescript
// Node.js 実装イメージ
async function runPollDispatch(params: PollDispatchParams): Promise<DispatchSummary> {
  const proc = spawn('bash', [params.commandFile], {
    stdio: ['ignore', fs.openSync(params.outputFile, 'w'), 'pipe'],
  });

  let lastSize = 0;
  let lastIdleTime = Date.now();
  let completionDetected = false;

  const poll = setInterval(async () => {
    const currentSize = fs.statSync(params.outputFile).size;
    if (currentSize > lastSize) {
      const newContent = readTailBytes(params.outputFile, lastSize);
      // progress marker 抽出
      extractProgressMarkers(newContent, params.progressFile);
      // opencode 完了シグナル
      if (newContent.includes('"type":"step_finish","reason":"stop"')) {
        completionDetected = true;
      }
      lastSize = currentSize;
      lastIdleTime = Date.now();
    }
    // タイムアウト判定...
  }, 1000);

  // watcher ベースに切り替え可能 (fs.watch)
  return new Promise((resolve) => {
    proc.on('exit', (code) => {
      clearInterval(poll);
      resolve(buildSummary(code, params.outputFile));
    });
  });
}
```

---

*このファイルは researcher エージェントによる静的解析成果物。*
*前回成果物 dependency-map.md の §4〜§9 を P2〜P4 について補完したもの。*
