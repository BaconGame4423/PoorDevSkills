<!--
同期影響レポート
==================
バージョン変更: 0.0.0 → 1.0.0
変更された原則: (該当なし - 初期バージョン)
追加されたセクション: 全セクション追加
削除されたセクション: (該当なし - 初期バージョン)
更新が必要なテンプレート:
  ✅ .poor-dev/templates/plan-template.md (憲法チェックセクション)
  ✅ .poor-dev/templates/spec-template.md (要件整合性)
  ✅ .poor-dev/templates/tasks-template.md (タスク分類)
  ⚠ README.md (作成が必要)
フォローアップ TODO: なし
-->

# PoorDevSkills 憲法

## コア原則

### I. AI優先開発

すべての開発活動は、コード生成、レビュー、最適化のためにAIモデル（GLM4.7を主要）を活用しなければなりません。AIアシスタントは副操縦士であり、人間の判断の代用品ではありません。重要な決定、セキュリティの影響、アーキテクチャの選択には人間の監督が必要です。

**根拠**: AIは適切に誘導された場合、開発速度とコード品質を加速します。GLM4.7は複雑な技術的課題に対する高度な推論能力を提供します。この原則は、AIが戦略的に使用されながら人間の説明責任を維持することを保証します。

**規則**:
- AIが生成したコードはコミット前にレビューしなければならない
- AIをコード探索、リファクタリング、テスト生成に使用する
- CASS（Code AI Search System）を活用して、ゼロから構築する前に既存のソリューションを検索する
- AIプロンプトにはコンテキスト、制約、受け入れ基準を含めなければならない
- AIを盲目的に信用しない - 重要なパスとセキュリティ機密コードを検証する

### II. スキルベースアーキテクチャ

すべての機能は、モジュール化された再利用可能なスキルとして実装しなければなりません。スキルは明確なインターフェース、ドキュメント、テスト可能性を持つ特定の機能をカプセル化します。スキルは独立して展開可能でテスト可能であるべきです。

**根拠**: スキルはコード再利用を促進し、重複を減らし、AIエージェントの特化を可能にします。モジュラーデザインはコードベースを保守可能にし、段階的な拡張を可能にします。

**規則**:
- 各スキルはSKILL.mdを持ち、明確な目的、入力、出力、使用例を含めなければならない
- スキルは最小限の依存関係で自己完結していなければならない
- スキルは分離してテスト可能でなければならない
- スキルは構成のために標準インターフェース（CLI、API）を使用しなければならない
- スキルは人間とAIエージェントの両方のためのドキュメントを含めなければならない

### III. レビュー主導品質（譲れない）

すべてのコード変更はマージ前に敵対的コードレビューを通過しなければなりません。レビューは新鮮なコンテキストを持つレビューアによるVDDスタイルの敵対的テストを使用します。3回の承認試行が許可されます。失敗した場合、タスクは拒否されてバックログに戻ります。

**根拠**: 敵対的レビューはバグ、セキュリティ問題、設計の欠陥を本番環境前にキャッチします。新鮮なコンテキストを持つレビューアは関係の偏りを回避し、重要な基準を維持します。

**規則**:
- すべてのサブタスク完了には `swarm_adversarial_review` を通じた敵対的レビューが必要
- レビューアは敵対的であり、雑学に対してゼロ許容である必要がある
- 3ストライクルール: 3回の拒否後、タスクは失敗し、バックログに戻る
- レビュー出力は以下を含まなければならない: 判定（APPROVED/NEEDS_CHANGES/HALLUCINATING）、見つかった問題
- APPROVED判定のコードは進行可能。NEEDS_CHANGESは修正が必要。HALLUCINATINGは優れたコードを示す
- すべてのPRにはレビュー用の差分とテスト出力を含めなければならない

### IV. 重要パスのテストファースト

重要なコードパス（認証、認可、支払い処理、データ整合性）はTDDを使用しなければなりません: テストが最初に書かれ、ユーザーによって承認され、失敗することが検証され、その後実装されます。これらのパスでは赤-緑-リファクタサイクルが強制されます。

**根拠**: TDDは重要な機能が設計によって正しいことを保証します。テストは生きたドキュメントとして機能し、回帰を防ぎます。

**規則**:
- 計画フェーズで重要なパスを特定する
- 重要なパスの実装前に失敗するテストを書く
- 実装コードを書く前にテストが失敗することを確認する
- テスト合格後にコード品質を向上させるためにリファクタする
- 非重要パスはテスト後または探索的アプローチを使用してもよい

### V. 段階的配信とMVP重視

機能は優先順位付けされたユーザーストーリー（P1、P2、P3）に分解されなければなりません。各ストーリーは独立して実装、テスト、展開可能でなければなりません。MVP（P1のみ）を範囲を拡大する前に配信します。

**根拠**: 段階的配信はリスクを軽減し、早期フィードバックを可能にし、価値を迅速に配信します。P1ストーリーは最小実行可能製品を表します。

**規則**:
- ユーザーストーリーは優先順位付けされなければならない（P1 = MVP、P2 = 拡張、P3 = 好ましい）
- 各ユーザーストーリーは独立してテスト可能でなければならない
- 各ユーザーストーリーはスタンドアロン価値を配信しなければならない
- 同じ優先レベルのユーザーストーリー間に依存関係はない
- P2またはP3を実装する前にP1（MVP）を検証する

### VI. スワーム調整

マルチエージェント開発は調整のためにSwarm Mailを使用しなければなりません。エージェントは適切な引き継ぎ、スレッド追跡、確認プロトコルを持つ構造化メッセージで通信します。ファイル予約は競合を防ぎます。

**根拠**: スワーム調整は並列開発を可能にし、競合を減らし、明確な監査証跡を提供します。エージェントは特化しながら共有コンテキストを維持できます。

**規則**:
- すべてのマルチエージェントセッションは `swarmmail_init` で初期化されなければならない
- エージェントは通信のために `swarmmail_send` を使用しなければならない（非公式チャネルではない）
- エージェントは `swarmmail_ack` でメッセージを確認しなければならない
- ファイル編集は変更前に `swarmmail_reserve` でパスを予約しなければならない
- 予約は完了後に `swarmmail_release` で解放されなければならない
- セッション引き継ぎには `hive_session_start` と `hive_session_end` を使用する

### VII. 可観測性とデバッグ性

すべてのコンポーネントは構造化ロギングと明確なエラーメッセージを通じてデバッグ可能でなければなりません。ログにはコンテキスト（リクエストID、エージェント名、タイムスタンプ）を含めなければなりません。エラーは実用的な修復手順を提供しなければなりません。

**根拠**: 可観測性はマルチエージェント、マルチモデル環境での迅速なデバッグを可能にします。明確なエラーメッセージは解決までの時間を短縮します。

**規則**:
- 一貫したフィールドを持つ構造化ロギング（適切な場合はJSON）を使用する
- エージェント/コンポーネント間の追跡のために相関IDを含める
- エラーは以下を含めなければならない: 何が起きたか、なぜ、どう修正するか
- ログは検索可能でフィルタ可能でなければならない（標準ログレベルを使用）
- 重要な操作のパフォーマンスメトリクスを追跡する

### VIII. 検証ゲート

すべてのサブタスク完了は終了前に検証ゲートを通過しなければなりません。ゲートには: 型チェック、テスト、リンティング、敵対的レビューが含まれます。検証をスキップするには明確な正当化が必要です。

**根拠**: 自動化されたゲートは問題を早期にキャッチし、コード品質を維持し、壊れたコードがコードベースに入るのを防ぎます。

**規則**:
- タスク完了をマークする前に型チェック（例: `tsc`、`mypy`、`ruff check`）を実行する
- タスク完了をマークする前にテスト（ユニット、統合、コントラクトとして適切）を実行する
- タスク完了をマークする前にリンティングとフォーマットチェックを実行する
- すべてのゲートはタスク完了のために合格しなければならない
- いかなるゲートをスキップする場合も正当化を文書化する

### IX. メモリと知識管理

学習、決定、パターンは将来の検索のためにHivemindに保存されなければなりません。エージェントは実装前にソリューションを再発明することを避けるためにHivemindをクエリしなければなりません。メモリはWHATだけでなくWHYを含みます。

**根拠**: 共有知識は開発を加速し、間違いの繰り返しを防ぎます。意味論検索は関連する過去のソリューションを見つけることを可能にします。

**規則**:
- 推論を含めて `hivemind_store` で決定と学習を保存する
- 機能を実装する前に `hivemind_find` でHivemindをクエリする
- 分類と検索のためにタグを含める
- `hivemind_validate` でメモリを定期的に検証する
- チーム共有のために `.hive/memories.jsonl` にメモリを同期する

### X. セキュリティとプライバシー

すべてのコードはセキュリティのベストプラクティスに従わなければなりません。シークレットは決してコミットしてはなりません。ユーザーデータは責任を持って扱われなければなりません。コードレビューにはセキュリティの考慮事項が含まれなければなりません。

**根拠**: セキュリティ脆弱性は深刻な結果をもたらす可能性があります。プライバシー違反は信頼を損ない、法的影響がある可能性があります。

**規則**:
- シークレット、APIキー、認証情報を決してコミットしない
- 機密データには環境変数またはシークレット管理を使用する
- すべてのユーザー入力をサニタイズする（XSS、インジェクション防止）
- 適切な認証と認可を実装する
- すべてのコード変更にセキュリティレビューが必須

## 技術スタック

### 主要AIモデル
- GLM4.7 (zai-coding-plan/glm-4.7) - コード生成、レビュー、分析用の主要モデル
- 特定のタスクには二次モデルを使用可能（例: 専門レビューアによる敵対的レビュー）

### 開発ツール
- OpenCode CLI - エージェントフレームワークとコマンド実行
- SpecKit - 仕様化と計画方法論
- Swarm Mail - マルチエージェント調整
- Hivemind - 知識管理と意味論検索
- CASS - 既存ソリューション発見のためのコードAI検索システム

### コード品質ツール
- 言語固有のリンティング（例: ESLint、Ruff、flake8）
- 型チェック（例: TypeScript、mypy、pyright）
- フォーマット（例: Prettier、Black、rustfmt）

## 開発ワークフロー

### 標準開発フロー（SpecKit + Review）

DevSkillsはSpecKitとReviewスキルを統合した構造化された開発フローを使用します。詳細は[AGENT.md](/home/bacon/DevSkills/AGENT.md)を参照してください。

#### フェーズ1: 仕様化
1. `/poor-dev.specify` を使用して優先順位付けされたユーザーストーリーを持つ機能仕様を作成する
2. 各ストーリーの明確な受け入れ基準を定義する
3. TDDを必要とする重要なパスを特定する

#### フェーズ2: 計画
1. `/poor-dev.plan` を使用して実装計画を作成する
2. plan.mdで憲法コンプライアンスをチェックする
3. アーキテクチャ、技術スタック、プロジェクト構造を定義する

#### フェーズ3: プランレビュー
1. `/review plan plan.md` を使用してプランをレビューする
2. PM・リスク・価値・批判のペルソナからフィードバックを収集する
3. GO/CONDITIONAL/NO-GO判定を受け、必要に応じて修正する

#### フェーズ4: タスク分解
1. `/poor-dev.tasks` を使用してユーザーストーリー別に整理されたタスクリストを作成する
2. 並列タスクを[P]でマークする
3. タスクシーケンスに検証ゲートを含める

#### フェーズ5: タスクレビュー
1. `/review tasks tasks.md` を使用してタスクをレビューする
2. テックリード・シニア・DevOps・ジュニアのペルソナからフィードバックを収集する
3. 依存関係と並列化の機会を確認する

#### フェーズ6: 設計レビュー（必要時）
1. `/review architecture data-model.md` を使用して設計をレビューする
2. アーキテクト・セキュリティ・性能・運用のペルソナからフィードバックを収集する
3. SOLID原則、拡張性、セキュリティを確認する

#### フェーズ7: 実装
1. `/poor-dev.implement` または `/swarm` を使用してタスクを実行する
2. 各タスクは検証ゲートを通過しなければならない
3. 進捗を追跡し、エラーを報告する

#### フェーズ8: 品質ゲート
1. `/finish` を使用して品質ゲートを実行する
2. 型チェック、リンティング、フォーマットチェック、テストを自動実行する
3. 全てのゲートをパスする必要がある

#### フェーズ9: 品質レビュー
1. `/review quality` を使用して実装をレビューする
2. QA・テスト設計・コード・セキュリティのペルソナからフィードバックを収集する
3. `swarm_adversarial_review` を実行して敵対的レビューを行う
4. 3ストライクルールを適用する

#### フェーズ10: フェーズ完了レビュー
1. `/review phase [フェーズ名]` を使用してフェーズをレビューする
2. 品質保証・リグレッション・文書化・UXのペルソナからフィードバックを収集する
3. Definition of Doneを確認する

#### フェーズ11: 検証とデプロイ
1. 完全なテストスイートを実行する
2. すべてのユーザーストーリーが独立して機能することを検証する
3. P1（MVP）の手動テストを実行する
4. デプロイしてフィードバックを収集する

### クイックリファレンス

| フェーズ | コマンド | 確認事項 |
|----------|----------|----------|
| 仕様 | `/poor-dev.specify` | ユーザー価値、明確な要件 |
| 計画 | `/poor-dev.plan` | 技術選択、アーキテクチャ |
| プランレビュー | `/review plan` | 価値、リスク、実現可能性 |
| タスク | `/poor-dev.tasks` | 依存関係、並列化 |
| タスクレビュー | `/review tasks` | 依存関係、並列化、網羅性 |
| 設計レビュー | `/review architecture` | SOLID、拡張性、セキュリティ |
| 実装 | `/poor-dev.implement` or `/swarm` | 実装の完全性 |
| 品質ゲート | `/finish` | 型チェック、リンティング、テスト |
| 品質レビュー | `/review quality` | テスト、コード品質、敵対的レビュー |
| フェーズ完了 | `/review phase` | DoD、統合、文書 |
| 検証 | 手動テスト | 全体動作、MVP |
| デプロイ | デプロイコマンド | 本番環境 |

## ガバナンス

### 憲法の権威
この憲法は他のすべての実践、ガイドライン、優先事項に優先します。すべてのコード、仕様、計画はこれらの原則に準拠しなければなりません。

### 改正プロセス
1. 明確な根拠を持つプルリクエストを通じて改正を提案する
2. 既存のコードとワークフローへの影響分析を含める
3. 改正はプロジェクトメンテナの承認が必要
4. 批准後に依存するテンプレートとドキュメントを更新する
5. セマンティックバージョニング（MAJOR/MINOR/PATCH）に従ってバージョンを増分する

### バージョニングポリシー
- **MAJOR**: 後方互換性のない原則の削除または再定義
- **MINOR**: 新しい原則の追加または実質的に拡張されたガイダンス
- **PATCH**: 明確化、言葉の改善、非意味論的改良

### コンプライアンスレビュー
1. すべてのPRは憲法コンプライアンスを検証しなければならない
2. `/poor-dev.analyze` は成果物間の違反をチェックする
3. 複雑性の違反は複雑性追跡テーブルで正当化されなければならない
4. 非準拠のコードはマージしてはならない

### ランタイムガイダンス
憲法原則を超える開発ガイダンスについては、以下を参照してください:
- `.poor-dev/templates/plan-template.md` - 計画構造とゲート
- `.poor-dev/templates/spec-template.md` - 仕様形式と要件
- `.poor-dev/templates/tasks-template.md` - タスク編成とパターン
- `.opencode/command/` ディレクトリのエージェント固有のガイダンス

## スキル開発ガイドライン

### スキル作成
1. `/skill create` を使用してSKILL.mdテンプレートで新しいスキルを初期化する
2. 明確な目的、入力、出力、使用例を定義する
3. テストケースと例を含める
4. 人間とAI（エージェント）の両方の使用パターンを文書化する

### スキル拡張
1. スキルのパフォーマンスと使用パターンを定期的にレビューする
2. Hivemindを活用して学習とベストプラクティスを保存する
3. 拡張前にCASSをクエリする - 別のエージェントが同様の問題を解決している可能性がある
4. 拡張と新しい機能でスキルドキュメントを更新する

### スキル統合
1. スキルはCLIまたはAPIインターフェースを公開しなければならない
2. スキルは他のスキルと構成をサポートしなければならない
3. スキルはエラーを適切に処理しなければならない
4. スキルは可観測性のためにロギングを含めなければならない

**バージョン**: 1.0.0 | **制定日**: 2026-02-08 | **最終改正**: 2026-02-08
